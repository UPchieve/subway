import { ACCOUNT_USER_ACTIONS } from '../constants'
import logger from '../logger'
import { Ulid } from '../models/pgUtils'
import {
  redisSubClient,
  redisClient,
  EXPIRED_KEY_CHANNEL,
} from './RedisService'
import * as UserActionService from './UserActionService'

/*
 *  This service tracks when a user is active or inactive on high-line.
 *
 *  The client may send many `trackActive` events, but we only care about the first
 * `trackActive` event in a given period and its corresponding `trackInactive` event.
 *
 *  We use Redis' (actually Valkey under the hood) TTLs and Keyspace Notifications
 *  to subscribe to key expirations and save an ACCOUNT_USER_ACTIONS.INACTIVE_ON_SITE
 *  user action when a key expires.
 *
 *  This protects us against things like network outages, connectivity issues, or the user
 *  walking away from their computer with the tab still open.
 *
 *  In those cases, our tracked time may drift from the user's actual time on site,
 *  but by no more than the TTL of the cache key.
 *
 *  A `clientUUID` generated by high-line allows us to differentiate between multiple devices
 *  connected under the same user. This UUID ensures we can match an `ACTIVE_ON_SITE` event
 *  with its corresponding `INACTIVE_ON_SITE` event when doing analysis.
 *
 *  Example:
 *    1. A high-line session creates clientUUID 123 and sends it to /user/track-presence/active
 *    2. `trackActive({ clientUUID: 123 })` is called - this is good! :D
 *    3. The session loses network connectivity - this is bad D:
 *    4. After 2 minutes (or whatever our TTL is), the Redis key expires; we log `ACCOUNT_USER_ACTIONS.INACTIVE_ON_SITE`
 *    5. Some time later, high-line reconnects and tiggers a trackActive again with clientUUID 123
 *    6. We create a new Redis key and log `ACCOUNT_USER_ACTIONS.ACTIVE_ON_SITE` - great! :D
 */

const PRESENCE_TTL_IN_SECONDS = 120
const PRESENCE_KEY_PREFIX = 'user-presence'

redisSubClient.on('message', expiredKeyListener)

function expiredKeyIsPresenceKey(channel: string, expiredKey: string) {
  return (
    channel === EXPIRED_KEY_CHANNEL &&
    expiredKey.startsWith(PRESENCE_KEY_PREFIX)
  )
}

function expiredKeyListener(channel: string, expiredKey: string) {
  if (expiredKeyIsPresenceKey(channel, expiredKey)) {
    const [_, userId, clientUUID] = expiredKey.split(':')
    /*
     * NOTE:
     * There's no ipAddress. ipAddress will be present when
     * high-line sends up a deliberate trackInactive event.
     * if it just expires, it's null
     */
    const params = {
      action: ACCOUNT_USER_ACTIONS.INACTIVE_ON_SITE,
      userId,
      clientUUID,
    }
    UserActionService.createAccountAction(params)
  }
}

function makeKey(userId: string, clientUUID: string) {
  return `${PRESENCE_KEY_PREFIX}:${userId}:${clientUUID}`
}

export async function trackActive({
  userId,
  ipAddress,
  clientUUID,
}: {
  userId: Ulid
  clientUUID: string
  ipAddress: string
}) {
  const key = makeKey(userId, clientUUID)
  const keyExists = await redisClient.get(key)
  if (!keyExists) {
    const params = {
      action: ACCOUNT_USER_ACTIONS.ACTIVE_ON_SITE,
      userId,
      clientUUID,
      ipAddress,
    }
    UserActionService.createAccountAction(params)
  }

  /*
   * always `set`- either it overwrites an existing key with the new TTL
   * or it creates it for the first time
   * setting 1 as the value is arbitrary. we never read it but we need a value
   */
  redisClient.set(key, 1, 'EX', PRESENCE_TTL_IN_SECONDS)
}

export async function trackInactive({
  userId,
  ipAddress,
  clientUUID,
}: {
  userId: Ulid
  clientUUID: string
  ipAddress: string
}) {
  const key = makeKey(userId, clientUUID)
  const deletedKeyCount = await redisClient.del(key)
  if (deletedKeyCount === 1) {
    const params = {
      action: ACCOUNT_USER_ACTIONS.INACTIVE_ON_SITE,
      userId,
      clientUUID,
      ipAddress,
    }
    UserActionService.createAccountAction(params)
  } else {
    /*
     * This can happen if the browser has paused js execution (tab is suspended)
     * and then resumes later (tab unsuspended).
     *
     * It could also happen if the user tabs away very quickly right as the page is loaded.
     * In that case, it's possible for the trackInactive POST to get here before the first trackActive
     */
    logger.warn(
      {
        userId,
        ipAddress,
        clientUUID,
      },
      `No cache key ${key} was found when attempting to set user as INACTIVE_ON_SITE. Probably not anything to worry about but getting a lot of these it might mean something is broken`
    )
  }
}
