import axios from 'axios'
import config from '../config'
import {
  addMessageToSessionById,
  getTutorBotSessionMessagesBySessionId,
  insertTutorBotSessionMessage,
} from '../models/Session'
import { tutor_bot_session_user_type } from '../models/Session/pg.queries'
import logger from '../logger'

interface TutorBotSessionMessage {
  tutorBotSessionUserType: tutor_bot_session_user_type
  message: string
  createdAt: Date
}

interface TutorBotSessionTranscript {
  sessionId: string
  messages: TutorBotSessionMessage[]
}

export const getTranscript = async (
  sessionId: string
): Promise<TutorBotSessionTranscript> => {
  const messagesInOrder = await getTutorBotSessionMessagesBySessionId(sessionId)
  return {
    sessionId,
    messages: messagesInOrder.map(m => m as TutorBotSessionMessage),
  }
}

const getBotResponseMessage = (
  conversation: string
): { assistant: string; system: string } => {
  const messages = conversation.split('<|end|>')
  const lastMessage = messages[messages.length - 1]
  const { system, assistant } = extractSystem(lastMessage)
  return {
    assistant: removeTurnMarkers(assistant),
    system,
  }
}

export const sendMessageAndGetUpdatedTranscript = async (
  userId: string,
  sessionId: string,
  message: string
) => {
  // Save the latest user message to DB and create the transcript of the conversation so far
  await insertTutorBotSessionMessage(
    sessionId,
    removeTurnMarkers(message),
    'student'
  )
  const transcript = await getTranscript(sessionId)
  const prompt = createPromptFromTranscript(transcript)
  const completion = await createChatCompletion(prompt, sessionId)
  const { assistant: botMessage, system } = getBotResponseMessage(completion)
  // Save bot response to session messages and append to the existing transcript
  const savedBotMessage = await insertTutorBotSessionMessage(
    sessionId,
    botMessage,
    'bot'
  )
  transcript.messages.push({
    tutorBotSessionUserType: 'bot',
    message: botMessage,
    createdAt: savedBotMessage.createdAt,
  } as TutorBotSessionMessage)

  return {
    message: transcript.messages[transcript.messages.length - 1].message,
    status: system.substring(
      system.indexOf('[[') + 2,
      system.lastIndexOf(']]')
    ),
  }
}

/**
 * Returns text generated by the Tutor Bot for the given prompt
 */
const createChatCompletion = async (
  prompt: string,
  sessionId: string
): Promise<string> => {
  try {
    const res = await axios.post(
      config.tutorBotBaseUrl,
      {
        inputs: prompt,
      },
      {
        headers: {
          Authorization: `Bearer ${config.tutorBotApiKey}`,
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      }
    )
    return res.data[0].generated_text
  } catch (err) {
    logger.error(
      {
        sessionId,
        error: err,
      },
      'Failed to get Tutor Bot response'
    )
    throw new Error('Could not get Tutor Bot response')
  }
}

const byteSize = (str: string) => new Blob([str]).size

const createPromptFromTranscript = (
  transcript: TutorBotSessionTranscript
): string => {
  let prompt = ''
  transcript.messages.forEach(m => {
    const senderTag =
      m.tutorBotSessionUserType === 'bot' ? '<|assistant|>' : '<|user|>'

    prompt += `${senderTag}\n${m.message}<|end|>${
      senderTag === '<|user|>' ? '<|system|>' : ''
    }\n`
  })

  // start removing the earlier messages
  if (byteSize(prompt) > 1024) {
    while (byteSize(prompt) > 1024) {
      prompt = prompt
        .split('<|end|>\n')
        .slice(1)
        .join('<|end|>\n')
    }
  }
  return prompt
}

const systemRegex = /^(<\|system\|>)\n.*(\[\[([A-Z]+)\]\])/gm

const extractSystem = (text: string): { assistant: string; system: string } => {
  const [system] = text.match(systemRegex) ?? ['']

  return {
    system,
    assistant: system ? text.replace(`${system} `, '') : text,
  }
}
/**
 * Removes chat turn markers from the string.
 * See https://huggingface.co/microsoft/Phi-3-medium-4k-instruct#chat-format
 */
const removeTurnMarkers = (text: string): string => {
  return text.replace(/<\|user\|>|<\|assistant\|>|<\|end\|>/g, '').trim()
}
