stages:
  - build
  - test
  - deploy
  - post-deploy

cache:
  # TODO: Try key as package-lock.json to speed up across branches.
  # key:
  #   files:
  #       - package-lock.json
  key: $CI_COMMIT_REF_SLUG
  paths:
    - .npm

variables:
  AUTO_DEVOPS_BUILD_IMAGE_CNB_ENABLED: "true"
  AUTO_DEVOPS_BUILD_IMAGE_CNB_BUILDER: "heroku/buildpacks:20"
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  NEW_RELIC_ENABLED: "false"
  NEW_RELIC_NO_CONFIG_FILE: "true"

# .build_docker:
#   stage: build
#   image: registry.gitlab.com/upchieve/subway/gitlab-ci-image
#   cache: []
#   services:
#     - docker:20.10.6-dind
#   id_tokens:
#     GITLAB_OIDC_TOKEN:
#       aud: api://AzureADTokenExchange
#   variables:
#     DOCKER_TLS_CERTDIR: ""
#     IMAGE_TAG: $AZURE_CONTAINER_REGISTRY/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA
#     AZURE_TENANT_ID: $AZURE_TENANT_ID
#   environment:
#     action: prepare
#   allow_failure: false
#   before_script:
#     - az login --service-principal --username $AZURE_IDENTITY_CLIENT_ID --tenant $AZURE_TENANT_ID --federated-token $GITLAB_OIDC_TOKEN
#     - az acr login --name $AZURE_CONTAINER_REGISTRY
#   script:
#     - echo $IMAGE_TAG
#     - docker build -t $IMAGE_TAG .
#     - docker push $IMAGE_TAG

# build_hackers:
#   extends: .build_docker
#   environment:
#     name: hackers
#   variables:
#     AZURE_IDENTITY_CLIENT_ID: $AZURE_IDENTITY_CLIENT_ID_HACKERS
#     AZURE_CONTAINER_REGISTRY: $AZURE_CONTAINER_REGISTRY_HACKERS
#   rules:
#     #- if: $CI_PIPELINE_SOURCE == 'merge_request_event'
#     #- if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#     - when: always
#     # - when: manual

# .deploy:
#   stage: deploy
#   image: mcr.microsoft.com/azure-cli:latest
#   id_tokens:
#     GITLAB_OIDC_TOKEN:
#       aud: api://AzureADTokenExchange
#   variables:
#     IMAGE_TAG: $AZURE_CONTAINER_REGISTRY/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA
#   before_script:
#     - az login --service-principal --username $AZURE_IDENTITY_CLIENT_ID --tenant $AZURE_TENANT_ID --federated-token $GITLAB_OIDC_TOKEN
#     - az extension add --name containerapp --upgrade
#   script:
#     - az containerapp update --name $CONTAINER_APP --resource-group $RESOURCE_GROUP --image $IMAGE_TAG
#     - az containerapp update --name $CONTAINER_APP_WORKER --resource-group $RESOURCE_GROUP --image $IMAGE_TAG

# deploy_hackers:
#   extends: .deploy
#   environment: 
#     name: hackers
#   resource_group: hackers
#   variables:
#     CONTAINER_APP: hackers-container-app-subway
#     CONTAINER_APP_WORKER: hackers-container-app-worker
#     RESOURCE_GROUP: hackers-resource-group
#     AZURE_IDENTITY_CLIENT_ID: $AZURE_IDENTITY_CLIENT_ID_HACKERS
#     AZURE_CONTAINER_REGISTRY: $AZURE_CONTAINER_REGISTRY_HACKERS
#   needs:
#     - job: build_hackers
#       artifacts: true
#   rules:
#     #- if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#     #  when: on_success
#     - when: manual

.tag_commit:
  stage: post-deploy
  #image: alpine/git
  script:
    # - echo $GITLAB_USER_NAME
    # - echo $GITLAB_USER_EMAIL
    # - git config --global user.name $GITLAB_USER_NAME
    # - git config --global user.email $GITLAB_USER_EMAIL
    #- git config --global user.name
    - timestamp=$(date +%Y%m%d%H%M%S)
    - deployment_tag="deployed-$CI_ENVIRONMENT_NAME-$timestamp"
    - echo $deployment_tag
    - git tag $deployment_tag
    - token_name=ci-git-tag
    - git push https://${token_name}:$REPO_ACCESS_TOKEN@gitlab.com/${CI_PROJECT_PATH}.git $deployment_tag
  # rules:
  #   - when: manual
    # 
  
tag_commit_hackers:
  extends: .tag_commit
  environment:
    name: hackers
  #needs:
    #- job: deploy_hackers
  # rules:
  #   - if: $CI_JOB_STATUS == "success"
  #script:
    #- !reference [.tag_commit, script]
    #- git tag -f "latest-hackers"
    #- git push origin -f "latest-hackers"

### TODO: Clean-up.
# build:
#   stage: build
#   image: "docker:20.10.6"
#   cache: {}
#   variables:
#     DOCKER_TLS_CERTDIR: ""
#   services:
#     - docker:20.10.6-dind
#   script:
#     - |
#       if [[ -z "$CI_COMMIT_TAG" ]]; then
#         export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG}
#         export CI_APPLICATION_TAG=${CI_APPLICATION_TAG:-$CI_COMMIT_SHA}
#       else
#         export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE}
#         export CI_APPLICATION_TAG=${CI_APPLICATION_TAG:-$CI_COMMIT_TAG}
#       fi
#     - export image_tagged="$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG"
#     - export image_cache="$CI_REGISTRY_IMAGE/cache-image:latest"
#     - export image_latest="$CI_APPLICATION_REPOSITORY:latest"
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#     - apk add --update curl tar
#     - (curl -sSL "https://github.com/buildpacks/pack/releases/download/v0.26.0/pack-v0.26.0-linux.tgz" | tar -C /usr/local/bin/ --no-same-owner -xzv pack)
#     - |
#       pack build "$image_tagged" \
#         --creation-time now \
#         --builder heroku/buildpacks:20 \
#         --buildpack registry.gitlab.com/upchieve/doppler-buildpack \
#         --buildpack heroku/nodejs@2.6.2 \
#         --buildpack heroku/procfile@0.6.2 \
#         --publish
#   rules:
#     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'

# testbackend:
#   stage: test
#   image: node:20.10.0-bullseye
#   variables:
#     NODE_OPTIONS: --max_old_space_size=5120
#   services:
#     - redis:latest
#   before_script:
#     - npm ci --cache .npm --prefer-offline
#   script:
#     - npm run test:backend
#   needs: []
#   rules:
#     - if: '$TEST_DISABLED'
#       when: never
#     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'

# # TODO: commenting out because it appears our current setup doesn't scale to having a lot of test data
# #       tests aren't currently super useful so until this is fixed we're ignoring them
# # testdatabase:
# #   stage: test
# #   image: node:20.10.0-bullseye
# #   tags:
# #     - upchieve
# #   variables:
# #     NODE_OPTIONS: --max_old_space_size=5120
# #     DOCKER_HOST: tcp://docker:2376
# #     DOCKER_TLS_VERIFY: 1
# #     DOCKER_CERT_PATH: "/certs/client"
# #     DOCKER_TLS_CERTDIR: "/certs"
# #     TESTCONTAINERS_HOST_OVERRIDE: docker
# #     CI_CONTAINER: "true"
# #   services:
# #     - docker:20.10.6-dind
# #   before_script:
# #     - npm ci --cache .npm --prefer-offline
# #     - curl -fsSL https://get.docker.com -o get-docker.sh
# #     - VERSION=20.10.6 sh ./get-docker.sh
# #   script:
# #     - npm run test:database
# #   needs: []
# #   rules:
# #     - if: '$TEST_DISABLED'
# #       when: never
# #     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'

# lint:
#   stage: test
#   image: node:20.10.0-bullseye
#   before_script:
#     - npm ci --cache .npm --prefer-offline
#   script:
#     - npm run lint
#   needs: []
#   rules:
#     - if: '$TEST_DISABLED'
#       when: never
#     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'

# lint_sql:
#   stage: test
#   image: node:20.10.0-bullseye
#   before_script:
#     - npm ci --cache .npm --prefer-offline
#   script:
#     - npm run lint:sql:check
#   needs: []
#   rules:
#     - if: '$TEST_DISABLED'
#       when: never
#     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'

# lint_database:
#   stage: test
#   image: node:20.10.0-bullseye
#   before_script:
#     - npm ci --cache .npm --prefer-offline
#   script:
#     - npm run lint:database:dry
#   needs: []
#   rules:
#     - if: '$TEST_DISABLED'
#       when: never
#     - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'
